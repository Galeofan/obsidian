---
tags:
  - Collections
---
java.util.Set - классы реализующие этот интерфейс <font color="#ff0000">не могут содержать дубликаты элементов.</font> Их также называют множества.
В коллекциях типа java.util.Set нет возможности указать индекс. Так же здесь нет возможности заменить элемент.
#### Hashset
- Создание коллекции:
```java
HashSet<String> names = new HashSet<>();
```

- Вставка элементов:
```java
names.add("Petr");
```

- Замена элемента. Коллекции java.util.Set не поддерживают замену элементов, потому что нет возможности явно указать ячейку. Это связано с внутренней реализацией коллекций типа java.util.Set

- Чтение данных.
Прочитать данные можно через цикл for-each:
```java
package ru.job4j.collection;

import java.util.HashSet;

public class UsageHashSet {
    public static void main(String[] args) {
        HashSet<String> names = new HashSet<>();
        names.add("Petr");
        names.add("Ivan");
        for (String name : names) {
            System.out.println(name);
        }
    }
}
```
На данный момент нужно запомнить, что для перебора элементов внутри java.util.List и java.util.Set нужно использовать цикл for-earch. 
Сам цикл for-each внутри использует механизм итератора.

Шаблон итератор основан на интерфейсе java.util.Iterable.
Он имеет три основных метода:
boolean hasNext() - проверяет на наличие следующего элемента в списке.
T next() - возвращает элемент из коллекции и переводит указатель на следующий элемент.
void remove() - удаляет элемент из коллекции и переводит указатель назад.
Указатель - это механизм позволяющий извлечь одиночный элемент из коллекции. Например для массива указатель будет индекс элемента.

- Удаление данных - метод <font color="#31859b">remove(Object o)</font>

Уникальность элементов в HashSet проверяется через методы equals и hashCode. Если мы хотим хранить в HashSet пользовательские типы данных, то нам нужно обеспечить эти модели методами equals и hashCode.

> [! Info]
> Всегда переопределяйте методы equals и hashCode в моделях данных. Модель данных - это класс, который является контейнером и описывает бизнес-модель приложения. Например: клиент банка, ученик, студент. Эти классы будут хранить информацию, но не будут выполнять логику.

