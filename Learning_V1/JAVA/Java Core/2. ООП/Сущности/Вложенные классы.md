---
tags:
  - ООП
---
В Java есть возможность определить класс внутри другого класса. Класс, полностью находящийся внутри другого класса, называется **вложенным** (nested)

### 1. Внутренние обычные (inner) классы
Вложенные классы могут быть статическими и нестатическими:
```java
package ru.job4j.oop;  
  
public class OuterClass {  
  
    class NestedClass { }  
      
    static class StaticNestedClass { }  
  
}
```

Внутренними (inner) называются _нестатические вложенные классы_.

Внутренние классы могут быть:
- просто внутренними (обычный нестатический внутренний класс). 
- локальными (класс, находящийся внутри некоторого блока кода другого класса (между фигурными скобками { }).
- анонимными (локальный класс без имени).


Основные случаи применения вложенных классов (всех видов): 
- **Логическая** группировка классов, использующихся в одном месте. Если какой-то класс создан для использования только одним другим  классом, то стоит вложить его в этот класс, чтобы показать связь этих классов.
- Повышение инкапсуляции. Если класс Y вынужден обращаться к членам класса X, которые иначе были бы объявлены с модификатором private, то следует вложить класс Y  в класс X. В таком случае эти члены можно будет объявить с модификатором private, но класс Y сможет к ним обращаться, а также класс Y будет скрыт от окружающего мира.
- Облегчение чтения и поддержки кода. Небольшие классы можно вложить во внешние классы, поближе к месту их применения.

Вложенные классы применяются, когда нужно написать вспомогательный код для другого класса. Также вложенные классы скрывают переменные и методы от остальной части программы, что является хорошим способом ограничения области их видимости.

Создадим примитивную модель автомобиля - класс Car, содержащий поля марка и модель, а также два внутренних класса Transmission и Brakes, представляющих трансмиссию и тормоза, с помощью методов которых автомобиль может ускоряться и тормозить:

```java
package ru.job4j.oop;

public class Car {
    private String brand;
    private String model;

    public Car(String brand, String model) {
        this.brand = brand;
        this.model = model;
    }

    public void startEngine() {
        System.out.println("Двигатель запущен");
    }

    public class Transmission {

        public void accelerate() {
            System.out.println("Ускорение");
        }

    }

    public class Brakes {

        public void brake() {
            System.out.println("Торможение");
        }

    }

}
```

В данном случае трансмиссия (класс Transmission) и тормоза (класс Brakes) - это внутренние системы автомобиля. В контексте самого автомобиля они не могут существовать отдельно от него, поэтому было логичнее сделать их его внутренними классами. Также внутренние классы - это усиление инкапсуляции. В них мы скрываем реализацию систем автомобиля, а также сама модель автомобиля становится более ясной за счет четкого разграничения его внутренних компонентов.

 Создадим класс CarMain и в методе Main выведем процесс пользования автомобилем:
```java
package ru.job4j.oop;

public class CarMain {
    
    public static void main(String[] args) {
        Car car = new Car("Марка", "Модель");
        Car.Transmission transmission = car.new Transmission();
        Car.Brakes brakes = car.new Brakes();
        car.startEngine();
        transmission.accelerate();
        brakes.brake();
    }

}
```

В следующих строках создаются объекты внутренних классов Transmission и Brakes:
```java
Car.Transmission transmission = car.new Transmission();
Car.Brakes brakes = car.new Brakes();
```
Обратите внимание на запись, например, переменной brakes - её тип записан как Car.Brakes. Так как класс Brakes вложен в класс Car, он не может быть создан и использован отдельно от класса Car. Хоть класс Brakes и имеет модификатор public и может быть создан где угодно, для его создания нужно указывать его внешний класс. Car.Brakes говорит о том, что переменная brakes имеет тип класса Brakes, вложенного в Car и являющегося его частью. По точке всегда можно понять вложенность классов. Если бы класс Brakes имел модификатор private, то он мог бы быть создан только в классе Car.


То же самое касается и создания объектов внутренних классов. Чтобы создать объект внутреннего класса, мы обращаемся через переменную экземпляра его внешнего класса (то есть объект внутреннего класса создаётся только в контексте внешнего):

```java
car.new Brakes();
```
Созданный объект внутреннего класса неявно содержит в себе ссылку на объект внешнего класса, независимо от конструкторов, объявленных во внутреннем классе. Это нужно для создания класса именно внутренним, а не обычным.


Технические особенности внутренних классов:
- Объект внутреннего класса может обращаться к объекту внешнего класса, но не наоборот.
```java
public class TripComputer {

    public String tripData = "Бортовой компьютер";

    public void getInfo() {
        System.out.println("Марка: " + brand);
        System.out.println("Модель: " + model);
    }

}
```
Класс TripComputer содержит переменную tripData. Мы не можем с ней работать напрямую из класса Car, так как она находится во внутреннем классе и скрыта областью видимости от внешнего класса, как уже было написано ранее. Для работы с ней нам понадобиться объект класса TripComputer.

- Использование нестатических переменных внешнего класса.
Добавим во внутренний класс TripComputer переменную model:
```java
private String model = "Модель TripComputer";
```
и в методе getInfo() вызовем переменные model из классов TripComputer и Car:
```java
public void getInfo() {
    System.out.println("Модель TripComputer: " + this.model);
    System.out.println("Модель Car: " + Car.this.model);
}
```
При обращении к нестатической переменной в классе напрямую, либо через this, мы всегда будем получать доступ к переменной того класса, откуда к ней обращаются.

- Создание объекта внутреннего класса в static-методе внешнего класса.
Здесь всё просто. Как мы знаем, статические члены класса принадлежат самому классу и могут использоваться без объекта этого класса, поэтому в статическом контексте для создания объекта внутреннего класса требуется создать сначала объект внешнего класса:
```java
public static TripComputer getTripComputer() {
    Car car = new Car("Марка", "Модель");
    Car.TripComputer tripComputer = car.new TripComputer();
    return tripComputer;
}
```

**Рекомендации Oracle по применению вложенных классов:**

- Это способ логической группировки классов, которые используются только в одном месте: если класс полезен только для одного другого класса, то логично встроить его в этот класс и сохранить их вместе. Вложение таких «вспомогательных классов» делает их пакет более упорядоченным.

- Это увеличивает инкапсуляцию: рассмотрим два класса верхнего уровня, A и B, где B требуется доступ к членам A, которые в противном случае были бы объявлены закрытыми. Скрывая класс B внутри класса A, члены A могут быть объявлены закрытыми, и B может получить к ним доступ. Кроме того, сам B может быть скрыт от внешнего мира.

- Это может привести к более удобному для чтения и сопровождения коду: вложение небольших классов в классы верхнего уровня помещает код ближе к тому месту, где он используется.

---

### 2. Локальные вложенные классы
**Локальный класс** - это разновидность внутреннего класса, в которой класс объявляется в другом классе внутри какого-либо блока кода (между фигурными скобками { }). Например, в теле оператора if, цикле for, методе, конструкторе и т.д.

Локальный класс можно объявить везде, где возможно объявить локальную переменную. Область видимости локального класса такая же, как и у локальной переменной. У локальных классов есть имя, и их можно использовать неоднократно.

Пример:
```java
package ru.job4j.oop;

public class Local {
    private String name = "Petr";

    public void getFullName() {
        final String surname = "Arsentev";

        class FullName {
            
            public void printFullName() {
                System.out.println(name + " " + surname);
            }
            
        }
        
        FullName fullName = new FullName();
        fullName.printFullName();
    }

    public static void main(String[] args) {
        Local local = new Local();
        local.getFullName();
    }
    
}
```

Локальные классы работают только с final или effective final переменными

Область видимости локального класса такая же, как и у обычной локальной переменной - в нашем случае локальный класс снаружи виден только в блоке кода, в котором он объявлен, то есть только в методе getFullName().

Локальные классы не могут содержать в себе статические объявления (классы, методы и т.д.). Допустимы только переменные-константы. Например:
```java
class FullName {
public static final String PATRONYMIC = "Empty";
```

Если локальный класс находится внутри статического метода, он имеет доступ только к статическим переменным внешнего класса.

Локальные классы - это просто способ инкапсуляции некоторого состояния и поведения локально. Применяется очень редко.

---

### 3. Анонимные классы
**Анонимный класс** - это локальный класс без имени. Анонимным классом следует пользоваться, если нужен локальный класс для одноразового использования.

В ситуации разового применения класса лучше прибегнуть к анонимному классу. Создадим класс BirdMain и в методе main() напишем анонимный класс:
```java
package ru.job4j.oop;

public class BirdMain {
    
    public static void main(String[] args) {
        Bird parrot = new Bird() { };
    }
    
}
```

В следующей строке в методе main мы создаем объект типа Bird
```java
Bird parrot = new Bird() { };
```
new Bird говорит о создании нового объекта анонимного класса. Его тело находится между фигурных скобок. Точка с запятой нужна, так как в этом месте кода мы одновременно и объявляем анонимный класс, и создаём его объект.

Получается в конструкцию **new Bird();** между скобками и точкой с запятой мы вставляем анонимный класс, заключенный в фигурные скобки.

В фигурных скобках находится полноценный внутренний класс, просто у него нет имени. Анонимный класс может обращаться к переменным и методам внешнего класса, в том числе static и private. Цель применения данного класса - это короткая запись, короткий класс для выполнения конкретной разовой задачи. При этом нам не потребуется создавать новые классы в программе для выполнения одной задачи, тем самым загромождая программу классами разового применения, раздувая код.

Важно понимать, что анонимный класс в данном случае - это наследник класса Bird

```java
package ru.job4j.oop;

public class BirdMain {

    public static void main(String[] args) {
        Bird bird = new Bird() {
            @Override
            public void fly() {
                System.out.println("Попугай пролетает над лужайкой");
            }
        };
    }

}
```

Тем самым анонимный класс упрощает код и убирает необходимость создавать новые классы для выполнения разовых задач. Анонимные классы следует использовать, когда уже есть тип, который описывает этот класс (либо его родителей), и задача будет выполняться один раз за всю работу программы (то есть нужен всего один экземпляр этого класса). Соответственно, и использоваться этот экземпляр будет в месте его создания, либо сразу после этого. Если подобную задачу нужно выполнять несколько раз, нужно создать локальный класс. Желательно применять анонимные классы к компактным задачам, чтобы не ухудшать чтение кода.


---

###  4. Статические вложенные классы
**Основные свойства статических вложенных классов:**

1) Как и другие статические члены, они принадлежат внешнему классу, а не экземпляру класса.

В прошлом уроке пояснялось, что внутренний класс не может существовать сам по себе (например, тормоза не могут существовать отдельно в контексте автомобиля), поэтому внутренний класс неявно имеет ссылку на объект внешнего класса.

Cтатическим элементам не требуется ссылка на какой-либо объект. Статический вложенный класс не привязан к объекту, объект статического вложенного класса не хранит в себе ссылку на внешний класс. Статический вложенный класс можно использовать, когда прямая связь между вложенным и внешним классом не требуется. Например, мы можем скрыть во внешнем классе реализацию чего-либо или другую информацию (первый пример кода ниже). 

То есть если вложенный класс является неотъемлемой частью внешнего класса, он должен быть внутренним, а если прямой связи нет, то его можно сделать статическим вложенным классом. При этом важно не забывать, что делать классы вложенными требуется только для логической группировки классов (если одни классы являются частью других, либо инкапсулируют что-либо из внешнего класса), чтобы повысить читаемость кода (все связанные классы будут в одном месте), а также повысить инкапсуляцию, вложив одни классы в другие. Если у рассматриваемых классов нет связи между собой, то и делать вложенность не требуется.

2) В их объявлении может быть указан любой модификатор доступа.

3) Они могут определять как статические, так и нестатические члены.

4) Они имеют доступ только к статическим членам во внешнем классе (включая private).

В следующем примере в класс Calculator вложен статический класс Multiple, с помощью которого можно вычислить квадрат числа.
```java
package ru.job4j.oop;

public class Calculator {
    public static class Multiple {

        private final int result;

        public Multiple(int number) {
            result = number;
        }

        public int getResult() {
            return result;
        }
    }

    public static Multiple getMultiple(int value) {
        int result = value * value;
        return new Multiple(result);
    }

    public static void main(String[] args) {
        Calculator.Multiple multiple = Calculator.getMultiple(3);
        System.out.println("Квадрат числа равен " + multiple.getResult());
    }
}
```

Объектов статического вложенного класса можно создать сколько угодно. Не путайте со статической переменной, которая создаётся только одна на всю программу.

**Выводы по вложенному статическому классу:**

- Применяется при отсутствии прямой связи с внешним классом (не является его частью).

- Может содержать в себе статические и нестатические переменные и методы.

- Изнутри этого класса есть доступ только к статическим переменным и методам внешнего класса (в том числе и private). К нестатическим полям и методам внешнего класса доступ можно получить только через ссылку на экземпляр внешнего класса.

- Сам класс виден окружающим согласно установленному модификатору доступа.

---

