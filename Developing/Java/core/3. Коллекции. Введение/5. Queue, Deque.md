---
tags:
  - Collections
---
#### Queue
**Очередь** - структура данных, которая представляет из себя хранилище однотипных элементов, в котором первым будет извлекаться тот элемент, который был туда и вставлен первым. Такой способ организации хранения данных называется **FIFO**, по первым буквам фразы, описывающей этот способ хранения – First-In-First-Out).

Очередь – очень удобный инструмент, который используется для моделирования реальных ситуаций ожидания клиентов в банке, вылета самолетов или передачи данных по Интернету.

Рассмотрим методы этого интерфейса:
1. метод add() – добавляет элемент в конец очереди (за исключением PriorityQueue, там элемент добавляется согласно своему приоритету)
2. Методы remove() и poll() – методы позволяют удалить верхний (первый) элемент из очереди.
	Разница между этими методами в том что если нас не устраивает поведение генерации непроверяемого исключения при пустой очереди, то используем метод poll(), иначе метод remove().
3. Метод offer() – предпринимает попытку вставки элемента в конец очереди.
	Почему только попытку – связано это с тем, что если в качестве реализации будет использована та, которая может иметь ограниченный размер, то при переполнении очереди метод offer() добавить элемент не сможет.
4. Методы peek() и element() – позволяют вернуть элемент из очереди без его удаления.
	Если метод element() вызывать на пустой очереди, то будет сгенерировано исключение NoSuchElementException.

**Подведем некоторые итоги:**
1. Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO.
2. В Java интерфейс Queue поддерживает все методы интерфейса Collection, включая вставку, удаление и т.д.
3. LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.
4. Очереди, доступные в пакете java.util, являются неограниченными очередями.
5. Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.

#### Deque
Интерфейс Deque расширяет интерфейс Queue.
Этот интерфейс также является очередью, но ее отличительной особенностью то, что эта очередь является двухсторонней, т.е. она поддерживает удаление и добавление элементов с обоих концов очереди. Таким образом, в отличие от Queue, здесь также можно организовать способ хранения элементов по принципу **LIFO** (сокращение по первой букве от описания этого принципа на английском языке Last In First Out – последний пришел, первый вышел). Такую структуру данных в программировании называют стеком. Пример аналогии из жизни – стопка тетрадей на проверку у учителя, учитель проверяет их по порядку и та тетрадь, которая была положена в эту стопку первой будет проверена последней.

Методы:
1. Добавление элементов. Как и ранее для интерфейса Queue у нас доступен метод add(), который позволяет добавить элемент в конец очереди. Однако тут конечно же есть особенности – в двухсторонней очереди добавление возможно с обоих ее направлений. Для этих целей определены еще 2 метода – addFirst() и addLast(). Функциональность этих методов легко определяется по их названиям – они позволят добавить элемент в начало и конец очереди соответственно.
2. Удаление элементов.
- Унаследованы poll() и remove() от Queue
- pop() – позволяет удалить головной элемент из очереди и вернуть его. Если очередь пуста – будет сгенерировано исключение NoSuchElementException.
- removeFirst() и pollFirst() – методы также позволят удалить первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.
- removeLast() и pollLast() – методы позволят удалить последний элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.
3. Чтение элементов. К ранее рассмотренным методам element() и peek(), которые позволяют прочитать первый элемент из очереди, для чтения также добавлены методы peekFirst() и peekLast() – методы позволяют соответственно прочитать без удаления первый и последний элемент из очереди.
Таким образом мы делаем вывод – предпочтительнее использовать методы poll(), pollFirst() и pollLast(), поскольку они не генерируют непроверяемых исключений, когда наша очередь пустая.
