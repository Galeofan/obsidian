---
tags:
---
Примитивные типы не являются ссылочными типами (объектами), поэтому если нам требуется объект примитивного типа, его значение должно быть упаковано в соответствующий класс-обёртку. Например, int в Integer или long в Long. Начиная с Java 5 такие преобразования выполняются компилятором автоматически и называются автоупаковкой и распаковкой.

**Автоупаковка происходит в следующих случаях:**
1) Если значение примитивного типа присваивается типу соответствующего класса-обёртки. Например:
```java
Integer b = 2;
```

Подробнее:
```java
package ru.job4j;

public class Box {

    public static void main(String[] args) {
        int a = 1;
        Integer b;
        b = a;
        System.out.println("Integer b = " + b);
    }

}
```
В следующей строке значение примитивного типа int присваивается типу Integer: 
```java
b = a;
```
Фактически типы int и Integer - разные, то есть должна была быть ошибка компиляции, но этого не произошло, так как компилятор автоматически преобразовывает примитивные типы в их соответствующие обёртки. Под капотом эта строка выглядит так:
```java
b = Integer.valueOf(a);
```
То есть значение примитивного типа int преобразуется в тип Integer, который возвращает метод valueOf().

2) Если значение примитивного типа передаётся в параметр метода, который предусматривает соответствующий класс-обёртку. Например, создадим в классе Box метод num():
```java
public static void num(Integer x) {
    System.out.println("Значение типа Integer: " + x);
}
```
В методе main() проверим вывод:
```java
int x = 2;
num(x);
```
Здесь мы передаём значение типа int в метод num, который принимает тип Integer. При передаче значения происходит автоупаковка из int в Integer.
Но если в классе имеется подходящий перегруженный метод с параметром того же типа, то компилятор выберет его.

---

**Распаковка происходит в следующих случаях:**
1) Если объект класса-обёртки присваивается переменной соответствующего примитивного типа. Например:
```java
Integer m = 3;
int n = m;
System.out.println("int n = " + n);
```
Под капотом строка int n = m выглядит так:
```java
int n = m.intValue();
```
2) Если объект класса-обёртки передаётся в параметр метода, который предусматривает примитивный тип. Распаковка здесь происходит аналогично упаковке
3) В выражениях с использованием различных операторов типа +, -, \*, /, % и т.д., если один или оба операнда являются объектами классов-обёрток. Например:
```java
Integer k = 5;
Integer l = 6;
System.out.println(k * l);
```
В методе println() перемножаться будут уже распакованные значения.

В операциях == и != распаковка не применяется, так как эти операторы выполняют сравнение объектов по ссылкам, а не по значениям.
```java
Integer g = 250;
Integer h = 250;
System.out.println(g == h);
```
Вывод будет false, так как сравнение будет по ссылкам, а они будут вести на разные объекты типа Integer в памяти, хоть и значение в них будет одинаковое. Исключением являются только кэшированные значения из пула Integer от -128 до 127 включительно. В этом диапазоне разные ссылки всегда будут вести на элемент из кэша.

```java
Integer v = 127;
Integer w = 127;
System.out.println(v == w);
```
Вывод будет true т.к. значения попадают в кэш

Важно понимать разницу между значением примитивного типа и этим же значением в обёртке:
- При работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит дополнительное время.
- Примитивные типы занимают меньше места в памяти.
- Если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя, понадобится упаковка.
- Обёртки - это такие же классы со своими методами, как и любые остальные, которые мы рассматривали. Поэтому работа со значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. (Например, для Integer это parseInt(), valueOf(), compareTo() и т.д.).

**Производительность.**
Появление классов-обёрток обусловлено тем, что Java - это объектно-ориентированный язык, и все сущности в идеале должны быть объектами. Но отказавшись от примитивных типов, упала бы производительность, поэтому к существующим примитивным типам добавили соответствующие классы-обертки, тем самым обеспечив гибкость работы с примитивными значениями.

Классы-обертки являются неизменяемыми, поэтому упакованное значение невозможно изменить. Следующий код будет приводить в постоянному пересозданию новых объектов и чрезмерному расходу памяти:
```java
Integer sum = 0;
for (int i = 128; i < 300; i++) {
    sum += i;
}
System.out.println(sum);
```
При перезаписи переменной sum каждый раз будет создаваться новый объект в памяти. Исключением являются только кэшированные значения из пула Integer от -128 до 127 включительно

Как уже упоминалось ранее, упаковка и распаковка значений будут в какой-то степени влиять на производительность программы. Для очень трудоёмких вычислений, где производительность критически важна, следует использовать примитивные типы. Для остальных программ на Java это скорее всего будет не так критично, но знать и помнить об автоупаковке и распаковке нужно