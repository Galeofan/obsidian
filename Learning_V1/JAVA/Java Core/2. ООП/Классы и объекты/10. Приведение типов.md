---
tags:
  - ООП
---
Механизм **приведение типа** позволяет относиться к объекту класса, так же как и к объекту любого класса в его иерархии.

```java
package ru.job4j.oop;

public class HierarchyUsage {
    public static void main(String[] args) {
        /* создаем объекта класса Car. */
        Car car = new Car();
//upcasting
        /* делаем приведение к типу родителя Transport. */
        Transport transport = car;
        /* делаем приведение к типу родителя Object. */
        Object object = car;

//downcasting
        /* Приведение типа при создании объекта. */
        Object objectCar = new Car();
        /* Приведение типа за счет понижения по иерархии. */
        Car carFromObject = (Car) objectCar;
//error
        /* Ошибка в приведении типа. */
        Object bicycle = new Bicycle();
        Car carBicycle = (Car) bicycle; // код завершится с ошибкой приведения типов ClassCastException
    }
}
```
##### Повышающее преобразование (upcasting):
Мы приводим объект Car к типу любого класса в его иерархии. Мы приводим конкретный тип к более общему типу данных.
Синтаксис этого приведения типов ничем не отличается от обычной записи объекта в переменную.
##### Понижающее преобразование (downcasting):
Понижающего приведения в коде лучше избегать, по той причине, что код становится не стабильным и нам приходится догадываться, к какому типу данных нужно сделать приведение. Так же при понижающем  приведении используется дополнительный синтаксис. Перед переменной нужно указать тип данных к которому нужно привести. Этот тип указывается в обычных скобках.

В JDK приведение типов (up casting) используется повсеместно.

```java
System.out.println(new Car());
System.out.println(new Bicycle());
System.out.println(new Object());
```
Этот метод принимает любой тип данных. Это происходит, потому что метод println принимает тип Object.
При его вызове происходит приведение типа к классу Object.

**Приведение типов** - очень важная составляющая реализации полиморфизма в Java. Очень важно разобраться в этом вопросе, в своем коде предпочтение отдавать использованию общих типов, которые определяются в интерфейсе, а не реализациями этих интерфейсов. В таком случае наш код становится более гибким, поскольку мы в любой момент можем заменить реализацию интерфейса, не нарушив общую структуру нашего кода.