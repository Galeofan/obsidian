---
tags:
  - ООП
---
1. **Что такое ООП?**
Это методология (парадигма) программирования, согласно которой вся программа представляется как набор взаимодействующих между собой Объектов, каждый из которых является экземпляром определенного Класса и обладает определенными Данными и набором доступных действий (Методов).

---
2. **Базовые концепции ООП?**
Основные принципы ООП - это наследование, инкапсуляция и полиморфизм. Отдельно можно выделить и абстракцию, позволяющую при работе с объектом не задумываться о его внутренней реализации.

---
3. **Укажите из каких элементов состоит класс. Расскажите о каждом из них.**
Класс состоит из полей (атрибуты) и методов (функции для работы с полями). Поля и методы называются членами класса. Поле (атрибут) класса - характеристика объекта, содержащая его состояние. Например, для коробки это может быть высота, ширина, длина, материал.

---
4. **Что такое конструктор?**
Это специальный метод, который отвечает за создание нового объекта и совершает инициализацию полей. Он не имеет возвращаемого значения и называется так же как Класс.
Один класс может иметь несколько конструкторов, отличающихся набором параметров (сигнатурой метода).
Конструктор, присваивающий значения всем полям модели данных называется Каноническим.
Если у класса явно не определен конструктор, то для него доступен т.н. Конструктор по умолчанию (конструктор без передаваемых параметров). При этом можно явно определить такой конструктор (без параметров).

---
5. **Можно ли наследовать конструктор?**
Конструктор не является членом класса, поэтому его нельзя наследовать, но с помощью super его можно вызвать. Когда нам нужно вызывать конструктор родителя? Всегда. Если в классе нет конструкторов, то конструктор по умолчанию вызывает конструктор по умолчанию своего родителя.

---
6. **Что такое перегрузка конструктора?**
Перегрузка конструктора - объявление в одном классе нескольких конструкторов с одинаковом именем, но с разными параметрами. Когда мы вызываем перегруженный конструктор, то из нескольких объявленных конструкторов, компилятор автоматически определяет нужный конструктор по его параметрам, которые указываются при вызове. Перегруженным считается конструктор у которого изменен порядок, тип, кол-во принимаемых параметров.

---
7. **Что такое статический метод?**
Статический метод – это метод, объявленный в классе при помощи ключевого слова _static_, который может использоваться без привязки к конкретному экземпляру класса (объекта). То есть, он может быть вызван, без создания объекта (экземпляра класса).
Статический метод может обращаться только к статическим переменным и/или к другим статическим методам класса.
Переменные экземпляра, объявленные как static, по существу являются глобальными переменными. При объявлении объектов такого класса копия статической переменной не создается. Взамен все экземпляры класса имеют дело с одной и той же статической переменной.
Статические методы обычно используются для выполнения операции, не зависящей от создания экземпляра. При этом, они широко используются для создания служебных (утилитных) или вспомогательных классов, поскольку их можно вызывать без создания объекта этих классов. В JDK используются служебные классы : Collections, Math, Arrays. Все методы этих классов являются статическими. Важно подчеркнуть, что нестатические методы имеют доступ к статическим переменным в классе и поэтому в нестатическом методе их можно использовать.
Когда же стоит использовать статические методы?
1. Для доступа или управления статическими переменными и другими статическими методами, которые не зависят от объектов;
2. Для служебных, вспомогательных классов и интерфейсов, поскольку не требуют создания объекта и соответственно, обеспечивают большую производительность;
3. Когда методу требуется доступ лишь к статическим полям класса.

---
8. **Что такое не статический метод?**
Не статические методы принадлежат объекту, вызвать их можно только через создание объекта. Не статические методы имеют доступ к статическим переменным в классе и поэтому в нестатическом методе их можно использовать. Не статические методы могут обращаться непосредственно как к методам класса (включая статические), так и к переменным класса (включая статические).
или
Обычный метод имеет привязку к объекту — экземпляру класса. Для его вызова необходимо сначала создать экземпляр класса (объект), затем обратиться к этому методу через точку. Обычный метод может обращаться к переменным в своем экземпляре класса.
При вызове обычного метода в него передается скрытый параметр — объект, у которого его вызывали. Этот параметр имеет имя this. Именно этот скрытый параметр — ссылка на объект, у которого вызвали метод — и отличает обычные методы от статических.
[Модификатор_доступа] Тип [Имя] (Параметры) { Тело метода }

---
9. **Для чего используется ключевое слово this?**
this используется для того, чтобы обратиться к полю объекта. т.е. через this мы получаем ссылку на текущий объект.
или
Ключевое слово **_this_** требуется для того, чтобы метод мог сослаться на вызвавший его объект.
По сути, это ссылка на экземпляр класса.

---
10. **Какой класс является базовым родительским классом для всех классов?**
В основе любого объекта лежит класс java.lang.Object. В классе Object есть методы, которые помогают стандартизовать работу объектов в программе. Какие манипуляции обычно выполняет программист с объектами? Он их сравнивает, копирует, выводит на консоль. Все эти действия описываются через методы класса java.lang.Object. А через механизм наследования они становятся доступны каждому объекту.

---
11. **Что такое наследование? Приведите примеры из реальной жизни.**
Наследование – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
- Наследование метода увеличить скорость легковым авто от основного класса транспорт
- Наследование цветком метода зацвести от класса растения
- Наследование быстрого режима стирки для новой модели машинки от класса стиральная машина
- Животные - Млекопитающие - Кошки

---
12. **Опишите процесс создания нового объекта.**
- Создаем переменную типа класса
- Записываем в эту переменную ссылку на объект
- С помощью оператора new резервируем кусок памяти и записываем в него данные нашего объекта

---
13. **Как вызвать метод из родительского класса?**
С помощью ключевого слова super.

---
14. **Что такое переопределение метода?**
Переопределение позволяет задать новое поведение уже существующего метода. Механизм переопределения (overriding) существует только при условии наследования.
Решение о вызове переопределенного метода принимается <font color="#ff0000">на этапе выполнения программы</font> при помощи т.н. позднего связывания. Вызывается метод из класса, на <font color="#31859b">который ссылается переменная</font> (справа).

---
15. **Можно ли переопределить статический метод?**
Статические методы принадлежат классу и не могут быть переопределены.

---
16. **Что такое сокрытие метода?**
Если же мы попытаемся переопределить статический метод, это будет называться сокрытием метода из суперкласса. 
Решение о том, какой метод будет вызван - из суперкласса или сокрытый в подклассе - принимается <font color="#ff0000">на этапе компиляции</font>, используется т.н. раннее связывание.
Вызывается метод из класса, объявленного в <font color="#31859b">типе переменной</font> (слева).

---
17. **Что такое виртуальная функция и используются ли они в Java?**
Виртуальная функция - это функция (метод), которая может быть переопределена наследником. То есть почти все нестатические методы Java - это виртуальные функции (кроме private или final методов, так как они не могут быть переопределены в связи с правами видимости).

---
18. **Что такое перегрузка метода?**
Перегрузка метода - механизм позволяющий создавать методы с одинаковыми именами, но с разными входными параметрами.
Условия перегрузки:
- изменение типа одного или нескольких параметров;
- изменение порядка параметров, при условии что они имеют разные типы;
- изменение количества параметров.

---
19. **Можно ли изменить тип возвращаемых данных при перегрузке метода?**
Изменение типа возвращаемого значения не приведет к перегрузке метода, более того - такой код даже не скомпилируется.

---
20. **Что такое множественное наследование? Как его можно реализовать в Java.**
Множественное наследование - возможность наследоваться от нескольких классов вместо одного. В Java проблемы сильной связанности классов и множественного наследования решает интерфейс.

---
21. **Что такое полиморфизм? Приведите примеры из реальной жизни.**
Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
или
Механизм обеспечивающий взаимозаменяемость классов реализующих один и тот же интерфейс без необходимости изменения основной логики и без необходимости знания о внутренней реализации этих классов
Примеры:
У всех автомобилей одинаковый интерфейс рулить или нажимать на педали, при этом сами автомобили разные
У пчелы, самолета, карлсона метод летать, при этом сами объекты совершенно разные
Пример из книги Шилдта: Собака чует запах кошки и начинает лаять, чует запах мяса и у нее начинается слюноотделение. Один и тот же механизм при разных входящих типах данных дает разный результа мат.

---
22. **Что такое инкапсуляция?**
Инкапсуляция – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали  
реализации от пользователя.

---
23. **Как реализована инкапсуляция в Java?**
С помощью инкапсуляции мы собираем вместе данные и методы управления ими в класс, а с помощью механизма сокрытия производится настройка доступа к этим данным и методам управления ими. Механизм сокрытия выполнен в виде модификаторов доступа и геттеров/сеттеров

---
24. **Можно ли применить модификаторы доступа к конструкторам?**
Да, конструктор можно сделать private. Такой подход используется в некоторых паттернах проектирования (singleton). Либо в случае, когда мы хотим запретить создание экземпляров класса.

---
25. **Что такое интерфейс?**
Интерфейс — это абстрактный класс, в котором не реализован ни один метод. С помощью этих методов описывается некое поведение, которое должно быть реализовано в классах, применяющих этот интерфейс.
Цель интерфейса - абстрагировать интерфейс класса от его реализации.
или
Интерфейс является разновидностью абстрактного класса и представляет собой следующий шаг на пути к абстракции. Интерфейс позволяет абстрагировать методы-реализации от методов-потребителей. Интерфейс описывает _форму_, а класс, его реализующий - _содержание_. Таким образом, это своеобразный “пульт”, с которым взаимодействует метод-потребитель.
Для указания на то, что класс реализует (имплементирует) интерфейс используется ключевое слово `implements`. Если класс, реализует не все методы, описанные в интерфейсе, то он должен быть объявлен абстрактным и уже его подклассы должны реализовать недостающие методы.
Интерфейсы могут наследоваться друг от друга и _поддерживают множественное наследование_. Интерфейсы создают собственную иерархию наследования и позволяют разным классам, никак не связанным друг с другом по иерархии, реализовывать один и тот же интерфейс.
Допустимые модификаторы доступа: `По умолчанию` и `public`. Для методов интерфейса неявно устанавливается модификатор `public`. Сам интерфейс должен быть явно объявлен как `public`.

---
26. **Перечислите элементы, которые может содержать интерфейс.**
- Поля (public static final)
- Конструкторов нет
- Методы только абстрактные или если с реализацией то дефолтные или статические
- Интерфейсы могут содержать вложенные классы и интерфейсы
- Обобщенные типы
- Также в интерфейсе возможно объявить Enum

---
27. **Можно ли создать объект интерфейса? Если да, то как?**
Непосредственно объект интерфейса создать нельзя, но можно создать объект класса, который реализует этот интерфейс.

---
28. **Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?**
Может.
С java8 - статические (static) или дефолтные (default)
C java9 - приватные

---
29. **Что такое абстракция?**
Абстрагирование – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.

---
30. **Что такое абстрактный класс?**
Это такой класс, в котором описывается общее состояние и поведение его будущих наследников. В нем абстрагируются (выделяются) главные свойства объекта, то есть предоставляется базовый функционал для классов-наследников, которые будут этот функционал реализовывать.

---
31. **Сколько абстрактных методов должен и может содержать абстрактный класс?**
Абстрактный класс может включать, а может и не включать абстрактные методы. Обычно класс называют абстрактным, если он имеет хотя бы один абстрактный метод.

---
32. **Может ли абстрактный класс содержать обычные методы?**
Методы класса не обязательно должны быть все абстрактными. Если реализация какого-либо метода общая для всех наследников, можно определить ее в абстрактном классе.

---
33. **Сколько объектов абстрактного класса можно создать в программе?**
Нельзя

---
34. **Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?**
Если подкласс (класс-наследник) не реализует все абстрактные методы суперкласса, то он должен быть объявлен абстрактным.

---
35. **Чем отличается интерфейс от абстрактного класса?**
Абстрактный класс — это класс, у которого не реализован один и более методов. Он нужен для реализации семейства классов (отношение IS-A). Выглядит как заготовка под будущую реализацию. Также это средство для повторного использования кода.

Интерфейс — это абстрактный класс, в котором все методы не реализованы (помимо default, private, static), а также нет нестатических переменных. Интерфейс задает семантику класса. Вы всегда будете уверены, что класс, который реализует какой-либо интерфейс, реализует и все его методы, то есть поддерживает заданную семантику.

Множественное наследование
Модификаторы доступа для методов в интерфейсе всегда паблик, в абстрактном классе все кроме прайват
Переменные в интерфейсе всегда паблик статик файнал, в абстрактном классе все кроме прайват
Разные ключевые слова при использовании

Любой интерфейс — это по существу абстрактный класс, но не наоборот. Несмотря на их схожесть, реального сходства между абстрактным классом и интерфейсом очень мало.

---
36. **Что такое вложенные классы? Зачем они нужны?**
Вложенный (nested) класс - класс, который определен внутри другого класса.
- Имеет область действия равную области действия внешнего класса;
- Имеет доступ к членам внешнего класса, в т.ч. закрытым;
- Внешний класс не имеет доступа к членам внутреннего;
- Вложенный класс не существует независимо от внешнего класса;
Вложенные классы делятся на:  
- Статические (static);
- Нестатические;
Когда используются?
- Когда реализуемый класс необходимо скрыть от других классов того же пакета, т.е. повысить инкапсуляцию;
- Когда нам необходим полный доступ к полям и методам класса, членом которого будет являться вложенный класс;
- Для увеличения логической связанности и читаемости кода, когда вложенный класс используется только во внешнем классе и располагается ближе к месту использования.

---
37. **Какие типы вложенных классов существуют в Java?**
Вложенные классы делятся на:
- Статические (static);
- Нестатические (внутренние классы);
- Внутренние;
- Локальные;
- Анонимные;

---
38. **Что такое внутренний класс? Когда он применяется?**
Внутренний (inner) класс - нестатический вложенный класс, связанный с объектом внешнего класса.
- Имеет доступ ко всем полям и методам (в т.ч. private) внешнего класса и _может ссылаться на них напрямую_;
- Имеет доступ ко всем полям и методам родителей внешнего класса, к которым имеет доступ внешний класс (public, protected);
- Может наследовать обычные классы и _внутренние классы, определенные во внешнем классе и его предках_;
- Может быть наследован _внутренними классами, определенными во внешнем классе и его наследниках_;
- Может имплементировать интерфейсы;
- Может содержать только нестатические методы, статические поля должны быть объявлены final;
Внутренние (inner) классы делятся на:
1. Внутренние классы - нестатические вложенные классы, связанные с объектом внешнего класса.
2. Локальные классы - объявленные внутри блока и не являющиеся членом внешнего класса. В этом случае можно рассматривать класс как локальную переменную типа класс.
3. Анонимные классы - наследуемые от класса, при объявлении не задается имя класса.

---
39. **Что такое статический вложенный класс? Когда он применяется?**
Статический вложенный класс - разновидность вложенного класса, объявляемая с модификатором static. В отличие от внутренних (inner) классов является более независимым. Принадлежит внешнему классу, а не экземпляру класса.
- Имеет доступ к статическим полям и методам внешнего класса (в т.ч. private);
- Если создан экземпляр класса, то можно получить доступ ко всем нестатическим полям и методам внешнего класса (в т.ч. private);
- Может содержать статические и нестатические поля и методы;
- Может быть создан в неограниченных количествах;
- Может наследовать обычные классы и _статические вложенные классы, определенные во внешнем классе и его предках_;
- Может быть наследован _любым классом_!;
- Область видимости определяется согласно модификатора доступа;

Когда используются?  
- Когда прямая связь между вложенным и внешним классом не требуется.

---
40. **Сколько объектов статического вложенного класса можно создать в программе?**
Статический вложенный класс может быть создан в неограниченных количествах.

---
41. **Что такое локальный класс? Когда он применяется?**
Локальный класс является подвидом внутреннего класса, объявленного внутри какого-либо блока кода `{}`. Не является членом внешнего класса и, по сути, является локальной переменной типа Класс.
- Имеет наименование, может быть использован неоднократно;
- Область видимости как у локальной переменной;
- В зависимости от того, в каком контексте объявлен - static, non static, имеет доступ либо только к статическим, либо ко всем (включая private) полям и методам внешнего класса;
- В нестатическом контексте содержит ссылку на внешний класс;
- Время жизни ограничено временем жизни блока кода, в котором объявлен локальный класс, либо существующими ссылками на объект этого класса;
- В объявлении локального класса допустим только модификатор final.
- Работает только с final или Effective final переменными;
- Может содержать в себе нестатические свойства и методы и статические константы (static final);
- Может наследовать:  
    - обычные классы;
    - внутренние классы, определенные во внешнем классе и его предках;
    - локальные классы, определенные в том же методе;
- Может быть наследован локальным классом, определенным в том же методе;
- Может имплементировать интерфейс;
Когда используются?  
- Локальные классы - это способ инкапсуляции. Используются для создания вспомогательных классов в пределах блока кода или метода;

---
42. **Что такое анонимный класс? Когда он применяется?**
Анонимный класс - это локальный класс без имени, который обязательно наследует какой-либо класс или реализует какой-либо интерфейс. Нужен в случае, когда нам необходим локальный класс для одноразового использования.
- Из него видны все свойства и методы внешнего класса (обычные и static), а так же public и protected свойства и методы родителя внешнего класса, т.е. те, которые видны во внешнем классе.
- Может содержать в себе только нестатические переменные и методы.
- Анонимный класс живет, пока на него существует ссылка;
- Виден только в методе, в котором определен;
- Не может быть наследован;

---
43. **Сколько объектов анонимного класса можно создать в программе?**
Анонимный класс не имеет имени и его экземпляр создается сразу же вместе с его объявлением, поэтому можно создать только один экземпляр анонимного класса.

---
44. **Что такое исключения? Какие типы исключительных ситуаций бывают?**
Исключение - это ненормальное состояние, которое возникает в кодовой последовательности во время выполнения. Другими словами, исключение является ошибкой времени выполнения.
Обработка исключений в Java управляется пятью ключевыми словами:  
1. try;  
2. catch;  
3. throw;  
4. throws;  
5. finally;
Все типы исключений являются подклассами встроенного класса Throwable, который делится на подклассы Error и Exception. Exception разделяется на подклассы RuntimeException и IOException.
Все подклассы Error и RuntimeException относятся к т.н. Непроверяемым исключениям. Такие исключения не обязательно включать в список throws.

---
45. **Назовите основные методы класса Object?**
1. **`public boolean equals(Object obj)`:** Определяет, равен ли один объект другому. Стандартная реализация этого метода проверяет равенство ссылок, но его часто переопределяют в пользовательских классах для проверки равенства по значению.

2. **`public int hashCode()`:** Возвращает хеш-код объекта, который используется хеш-таблицами, такими как **`HashMap`**. Переопределение этого метода важно при переопределении метода **`equals`**, чтобы поддерживать общий контракт для методов **`hashCode`** и **`equals`**.

3. **`public String toString()`:** Возвращает строковое представление объекта. Стандартная реализация возвращает строку, состоящую из имени класса объекта, символа **`@`** и его хеш-кода в шестнадцатеричном формате. Часто переопределяется для предоставления более информативного представления объекта.

4. **`protected Object clone()`:** Создает и возвращает копию объекта. Для использования этого метода класс должен реализовать интерфейс **`Cloneable`**, иначе будет выброшено исключение **`CloneNotSupportedException`**.

5. **`public void finalize()`:** Вызывается сборщиком мусора перед тем, как объект будет уничтожен. Этот метод может быть использован для освобождения ресурсов, занятых объектом. Однако его использование не рекомендуется, так как работа сборщика мусора не предсказуема.

6. **`public final Class<?> getClass()`:** Возвращает объект **`Class`**, который представляет класс данного объекта. Это может быть использовано для получения информации о классе во время выполнения.

7. **`public final void notify()`**, **`public final void notifyAll()`**, и **`public final void wait(long timeout)`:** Это методы, которые используются для синхронизации потоков, ожидающих доступ к объекту.

---
46. **Что такое шаблоны проектирования?**
Паттерн проектирования— это часто встречающееся решение определённой проблемы при проектировании архитектуры программ. Паттерны проектирования возникли как общепринятые лучшие практики (best practice) в создании приложений.
- Порождающие паттерны (creational patterns) - обеспечивают гибкость в создании;
- Структурные паттерны (structural patterns) - заботятся о связях между объектами;
- Поведенческие паттерны (behavioral patterns) - эффективная коммуникация;

---
47. **Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.**
Шаблон Декоратор (Wrapper - обертка) это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

Структура:  
1. Компонент - задает общий интерфейс как обёрток, так и оборачиваемых объектов.  
2. Конкретный компонент - содержит базовое поведение, изменяемое декораторами.  
3. Базовый декоратор - хранит ссылку на вложенный объект-компонент, который может быть как оборачиваемым объектом, так и объектом-обёрткой. Делегирует все свои операции вложенному объекту. Дополнительное поведение определяется в конкретных декораторах.  
4. Конкретные декораторы - различные вариации декораторов, содержащие добавочное поведение, выполняемое до или после вызова аналогичного поведения обернутого объекта.  
5. Клиент - может оборачивать простые компоненты и декораторы в другие декораторы (слоями), работая со всеми через общий интерфейс компонентов.
Пример из жизни:  
Любая одежда— это аналог Декоратора. Применяя Декоратор, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой— надевая свитер, вы не перестаёте быть собой, но получаете новое свойство— защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор— плащ, чтобы защититься и от дождя.

---
48. **Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.**
Шаблон стратегия (Strategy) - это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
Структура:  
* Context (Strategy client) - Класс - клиент, который содержит:  
1. Поле - ссылку на конкретную реализацию стратегии;  
2. Сеттер для установки ссылки на конкретную реализацию стратегии;  
3. Метод для вызова конкретного метода из назначенной реализации стратегии;  
* Strategy - Интерфейс или абстрактный класс, описывающий поведение конкретных стратегий;  
* Concrete strategy - Конкретные классы-стратегии, реализующие методы, описанные в Strategy;

---
49. **Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.**
Шаблон Singleton - это порождающий шаблон проектирования, который:  
1. Гарантирует, что в приложении может быть только один экземпляр некоторого класса;  
2. Предоставляет глобальную точку доступа к этому экземпляру через отдельный метод;

1. Запрещаем наследование класса через final
2. Создаем приватный конструктор
3. Поле instance (private static)
4. Метод getInstance() (public static), который является глобальной точкой доступа к экземпляру класса. Он проверяет был ли уже создан объект (присвоен переменной instance) и возвращает его или создает новый.

Пример из жизни: Классный журнал в школе, который принадлежит только одному классу

---
50. **Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.**
Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

1. Продукт определяет общий интерфейс объектов, которые может произвести создатель и его подклассы.
2. Конкретные продукты содержат код различных продуктов. Продукты будут отличаться реализацией, но интерфейс у них будет общий.
3. Создатель объявляет фабричный метод, который должен возвращать новые объекты продуктов. Важно, чтобы тип результата совпадал с общим интерфейсом продуктов.Зачастую фабричный метод объявляют абстрактным, чтобы заставить все подклассы реализовать его по-своему. Но он может возвращать и некий стандартный продукт.Несмотря на название, важно понимать, что создание продуктов не является единственной функцией создателя. Обычно он содержит и другой полезный код работы с продуктом. Аналогия: большая софтверная компания может иметь центр подготовки программистов, но основная задача компании— создавать программные продукты, а не готовить программистов.
4. Конкретные создатели по-своему реализуют фабричный метод, производя те или иные конкретные продукты.
Фабричный метод не обязан всё время создавать новые объекты. Его можно переписать так, чтобы возвращать существующие объекты из какого-то хранилища или кэша.

**Проще говоря,** паттерн позволяет использовать один класс для создания объектов разной реализации интерфейса и делегировать логику дочерним классам.

---
51. **Что такое enum? Когда можно его применять?**
Enum - класс-перечисление, содержащий набор констант или статических объектов, каждый из которых является объектом анонимного класса.
Применяется для хранения неизменяемых значений - таких как Статус.
Может содержать:  
- Поля;  
- Методы;  
- Конструкторы (private);
Может быть объявлен:  
1. Как отдельный класс (public);  
2. Как вложенный класс (public, private);  
3. Как внутренний класс (private);
Наследование и интерфейсы:  
1. Может имплементировать интерфейсы;  
2. Не может наследовать классы и быть наследованным;

---
52. **Что такое record? Когда можно его применять?**
Record - это неизменяемая модель данных. Record используется для быстрого создания стандартной модели данных - класса носителя данных. Добавлен в Java 14.
```Java  
public record PersonRecord(String name, int age) { }  
```
- Поля private final **name** и private final **age**.;
- Канонический конструктор (параметры которого - поля класса);
- Методы _equals()_ и _hashCode()_;
- Шаблонный метод _toString()_;
- Геттеры реализованы через методы _.name()_ и _.age()_;
> [!info]  
Так как это неизменяемая модель данных, то у нее отсутствуют сеттеры, а все поля являются final.
- В record можно добавлять ТОЛЬКО статические поля.
- В record можно добавлять любые методы (статические и нестатические).
- Record является **final**, поэтому наследование этого класса невозможно.
- Record наследует java.lang.Record, поэтому не может наследовать другие классы.
- Record может реализовывать Интерфейсы.
Для записей типа record доступен особый вид конструктора, называемый **компактным конструктором**. Он используется в случае, когда нам необходимо добавить в стандартный конструктор какую-то дополнительную логику (например, валидацию).
Если в record уже объявлен компактный конструктор, то явно объявить еще и канонический конструктор в этом классе невозможно, так как при объявлении компактного конструктора автоматически создается конструктор по умолчанию, чтобы провести инициализацию всех полей перед выполнением команд компактного конструктора, следовательно нельзя еще раз объявить в классе такой же конструктор с теми же параметрами.
``` Java  
public record Contact(String name, String email) {  
public Contact {  
if(!email.contains(“@”)) {  
throw new IllegalArgumentException(“Invalid email”);  
		}  
	}  
}
```

---
53. **Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?**
В отличие от класса String, который является неизменяемым (иммутабельным), объекты StringBuffer и StringBuilder являются изменяемыми и используются для операций над строками. Например для конкатенации или переворачивания строк. StringJoiner имеет специальные методы для соединения строк по некоторым условиям, например можно добавить разделители, суффиксы и постфиксы.

---
54. **Чем отличаются StringBuffer и StringBuilder?**
StringBuffer потокобезопасен. StringBuilder более быстрый;

---
55. **Каким образом производится экранирование символов и зачем это нужно?**
Экранирование производится при помощи обратного слэша “". Оно необходимо для описания управляющих последовательностей и для передачи в строковый литерал символов, являющихся частью синтаксиса языка “как есть”. Например, двойных кавычек.

---
56. **Что такое управляющие последовательности?**
Управляющая последовательность это комбинация в виде обратного слэша и экранируемого им символа:
1) ' - Добавляет одинарную кавычку  
2) " - Добавляет двойную кавычку  
3) \ - Добавляет обратный слэш  
4) \r - Возврат курсора в начало строки  
5) \n - Перевод курсора на новую строку  
6) \f - Прогон страницы  
7) \t - Табуляция  
8) \b - Возврат курсора на одну позицию назад

---
57. **Зачем нужно форматирование данных? Метод format()**
Форматирование необходимо для выведения чисел, строк, даты в нужном нам формате.

---
58. **Что такое varargs? В каких случаях стоит его применять?**
varargs или variable arguments - это механизм, который позволяет обрабатывать аргументы произвольной длины. Он обозначается тремя точками `...` после объявления типа и подразумевает 0 и более передаваемых аргументов, например:
```Java  
public static String text(int x, int y, String… strings) {  
```
Все аргументы неявно помещаются в массив и передаются в метод. Если аргументов нет, то длина массива, полученного в методе, будет равна 0.  
Особенности  
* Указать varargs можно_только_как параметр какого-либо метода;  
* Параметр varargs всегда должен быть объявлен последним;  
* В сигнатуре метода может объявлен только один параметр varargs;  
* Методы с аргументами произвольной длины можно перегружать;
Появился в Java 5.

---
59. **В каких случаях может возникнуть неоднозначность при работе с varargs?**
Неоднозначность может возникать в случаях перегрузки метода с аргументами переменной длины.
1. Два метода с varargs и разными типами. Вызываем метод без аргументов.
2. Два метода, в одном varargs, во втором первый аргумент того же типа, что и varargs. Вызываем метод с передачей одного аргумента.

---
60. **Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?**
Класс Formatter, Метод printf()