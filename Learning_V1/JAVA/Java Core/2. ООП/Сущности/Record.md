---
tags:
  - ООП
---
### Record
Record дает возможность записать стандартную модель данных в виде одной строки, то есть с помощью record можно избавиться от шаблонного кода, который приходится писать в каждой модели данных.


Record - это **неизменяемая** модель данных, в которой:  

- Поля, переданные в параметрах, являются private и final по умолчанию.
- Код имеет канонический конструктор, параметры которого - это все поля данного класса.
- Доступ к полям осуществляется через методы типа имя_поля(). Тот же геттер, только без слова get в имени метода. Методов типа set класс record не имеет, так как все поля объявлены как final, поэтому record является неизменяемым.
- Определены методы equals() и hashcode(), включающие все поля класса.
- Определен шаблонный метод toString() для вывода полей класса на печать.

Record удобно применять, когда у модели могут добавляться или удаляться поля. Достаточно просто вписать новое поле в запись record и в класс автоматически будут внесены изменения. В случае же с обычным классом нужно будет вручную вписывать поле в модель, менять конструктор, методы equals(), hashcode(), toString(), добавлять или удалять геттеры.

**Особенности**
Record имеет некоторые особенности, перечисленные ниже:
- В record можно добавлять _только_ статические переменные (как константы, так и обычные статические переменные)
- В record можно добавлять свои методы, как нестатические, так и статические
- Record является final, поэтому наследование этого класса невозможно. Сам record наследовать другие классы не может, так он унаследован от java.lang.Record. Но record может реализовывать интерфейсы

**Конструкторы**
- По умолчанию record имеет канонический конструктор - это конструктор, принимающий все поля класса в качестве параметров. Канонический конструктор выглядит как:
```java
public PersonRecord(String name, int age) {
    this.name = name;
    this.age = age;
}
```
Такой же конструктор неявно создается в record по умолчанию. Если его явно объявить в record, то будет использоваться объявленный конструктор вместо канонического. Конструктор по умолчанию при объявлении явного канонического конструктора создан не будет.

- Если нам нужен конструктор с какой-то логикой помимо обычной инициализации полей, можно создать **компактный конструктор**:
```java
package ru.job4j.record;

public record PersonRecord(String name, int age) {
    public PersonRecord {
        if (age > 101) {
            throw new IllegalArgumentException("Возраст должен быть менее 101");
        }
    }
}
```
Данный конструктор называется компактным, так как в нем поля не инициализируются явным образом. Инициализация проходит неявно перед выполнением команд, находящихся внутри конструктора. Данная инициализация автоматически будет проходить в любом переопределенном конструкторе. Это гарантирует, что все поля будут инициализированы.

Если в record уже объявлен компактный конструктор, то явно объявить еще и канонический конструктор в этом классе невозможно, так как при объявлении компактного конструктора автоматически создается конструктор по умолчанию, чтобы провести инициализацию всех полей перед выполнением команд компактного конструктора, следовательно нельзя еще раз объявить в классе такой же конструктор с теми же параметрами.