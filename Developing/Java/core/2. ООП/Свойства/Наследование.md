---
tags:
  - ООП
---
### Общая инфа
**Наследование** - механизм ООП, благодаря которому свойства родительского элемента доступны дочернему элементу.

В Java все объекты наследуются от класса java.lang.Object. То есть на наследовании строится весь язык программирования Java.



Базовым элементом в Java является объект. Язык Java спроектирован таким образом, что в основе любого объекта лежит класс java.lang.Object.
В классе Object есть методы, которые помогают стандартизовать работу объектов в программе. 

Какие манипуляции обычно выполняет программист с объектами? Он их сравнивает, копирует, выводит на консоль. 
Все эти действия описываются через методы класса java.lang.Object. А через механизм наследования они становятся доступны каждому объекту.

### Элементы наследования
Давайте перечислим элементы, которые есть в классе и отметим, какие из них наследуются.
1. Конструкторы. Этот элемент <font color="#ff0000">не наследуются</font>, но он активно принимает участие в наследовании. Каждый из описанных пунктов будет рассмотрен ниже в этом модуле. Сейчас ваша задача понять смысл наследования, а не разобраться в его деталях.
2. Поля класса. Они <font color="#00b050">могут наследоваться</font> и использоваться в дочернем классе, но я настоятельно не рекомендую это делать. В разделе "Инкапсуляция" мы рассмотрим тему использования полей через наследование. 
3. Методы. Самый интересный для нас элемент в теме <font color="#00b050">наследования</font>. Они то и делают основную работу в наследовании.

### Множественное наследование
В Java класс может наследовать только один другой класс. Это ограничение можно обойти за счет другого механизма - полиморфизма.

### Примеры наследования
```java
package ru.job4j.inheritance;

public class Cat {
    public boolean canPurr() {
        return true;
    } 
}
```

Чтобы наследовать один класс от другого, нужно после имени класса написать ключевое слово extends и далее указать, какой класс нужно наследовать.

```java
package ru.job4j.inheritance;

public class ToyCat extends Cat {
    public boolean canBeWashByWashMachine() {
        return true;
    }
}
```

---
### Ключевое слово super
Иногда в программе при наследовании в подклассах (наследниках, потомках и т.п.) требуется получить ссылку непосредственно на его суперкласс (класс родитель, предок и т.п.). В Java для этих целей используется ключевое слово **super**

По аналогии с ключевым словом this, super может быть использован для следующих целей:
1. Для вызова конструктора суперкласса:
`super(список_параметров_конструктора)`
2. Для вызова метода суперкласса:
``super.название_метода(список_ параметров _метода)

Конструктор не является членом класса, поэтому его нельзя наследовать, но с помощью super его можно вызвать. Когда нам нужно вызывать конструктор родителя? Всегда. Если в классе нет конструкторов, то конструктор по умолчанию вызывает конструктор по умолчанию своего родителя.

Вызов метода super() должен быть **всегда первым** в конструкторе. Это обусловлено тем, что мы сначала должны инициализировать поля родителя, а потом уже дочернего класса.

В иерархии классов конструкторы вызываются в порядке наследования, начиная с суперкласса и заканчивая подклассом. Более того, поскольку super() должен быть первым оператором, выполняемым в конструкторе подкласса, этот порядок не изменим, независимо от того, используется ли форма super().

---
### Переопределение метода
**Переопределение метода** (overriding)- механизм, позволяющий задать новое поведение для уже существующего метода.
Механизм переопределения существует только при условии наследования.

На собеседовании могут спросить что такое [[_Термины#Виртуальная функция|виртуальная функция]] То есть почти все нестатические методы Java - это виртуальные функции (кроме private-методов, так как они не могут быть переопределены в связи с правами видимости). Статические методы принадлежат классу и не могут быть переопределены, поэтому они не являются виртуальными функциями.

> [!info]
> Переопределять можно только _нестатические_ методы. Если же мы попытаемся переопределить статический метод, это будет называться 
>[сокрытием](https://docs.oracle.com/javase/tutorial/java/IandI/override.html) метода из суперкласса 

---
### Сокрытие метода 
**Сокрытие метода** - это когда дочерний класс определяет статический метод с такой же сигнатурой, что содержится в родительском классе
Статические методы можно наследовать, но переопределить их нельзя.

Если в дочернем классе требуется изменить статический метод из родительского класса, это называется "Сокрытием статического метода" (hiding) в отличие от "переопределения" для нестатического метода (overriding).

**Вывод:**
- Статический метод, определенный в дочернем классе, скрывает метод с той же сигнатурой в родительском классе. 
- Статические методы можно унаследовать, но нельзя переопределить.
- Во время компиляции статические методы связаны с типом объявленной переменной, то есть какой класс объявлен в типе, статический метод того класса и будет вызван.

---
### Аннотация @override
Можно выделить 2 действия связанных с [[_Термины#Аннотация|аннотацией]]: **анализ кода** и **генерация нового кода** на основании существующего. То есть сама аннотация никак не влияет на код, ее используют другие программы.

Аннотации могут объявляться над классом, полем, методом.


