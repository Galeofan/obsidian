**`KeycloakSessionFactory`**
- Глобальная сессия на весь сервер (singleton)
- Хранит реестр всех `Spi` и всех `ProviderFactory`
- Живет пока запущен keycloak
```java
protected Set<Spi> spis = new HashSet();

------------------------------------------------------------------------------------------------------------

protected volatile Map<Class<? extends Provider>, Map<String, ProviderFactory>> factoriesMap = new HashMap();

Class<? extends Provider> - тип провайдера .class
Map<String, ProviderFactory> - имя провайдера, фабрика

Выглядит примерно так:
{
  PhoneProvider.class: {
      "default": DefaultPhoneProviderFactory
  }
}
```

---

**`ProviderFactory<T extends Provider>`**
- Один инстанс на сервер для каждого провайдера (по `getId()`) (singleton)
- Живёт от старта сервера до его остановки.
- keycloak создаёт одну фабрику провайдера для каждого spi и запихивает в мапу factoriesMap выше
- Отвечает за:
    - `init(Config.Scope)` — чтение конфигурации и инициализация глобальных ресурсов.
    - `postInit(KeycloakSessionFactory)` — работа после инициализации всех фабрик.
    - `create(KeycloakSession)` — создание **конкретного провайдера** под глобальную сессию.
    - `close()` — освобождение глобальных ресурсов на shutdown.

---

**`KeycloakSession`**
- Контекст выполнения: «единица работы» Keycloak (обычно один HTTP-запрос).
- Содержит:
    - ссылки на JPA-контекст, транзакции;
    - текущий `Realm`, `Client`, контекст авторизации;
    - **кэш провайдеров** для этой сессии: `Map<Class<? extends Provider>, Provider>`
- Умеет создавать/кешировать провайдеры через `getProvider(...)`

--- 

**`Provider`**
- Экземпляр на `KeycloakSession` («на каждый запрос»).
- Должен быть легковесным, хранить только state уровня запроса и ссылку на `KeycloakSession`.
- Метод `close()` вызывается при закрытии `KeycloakSession`

- пришёл запрос на авторизацию → создаётся KeycloakSession
- внутри сессии запрашивается UserProvider → создаётся Provider instance
- запрос завершился → Provider закрывается вместе с сессией
- Т.е. жизненный цикл Provider полностью совпадает с жизненным циклом KeycloakSession.
```java
[HTTP Request] 
    ↓
KeycloakSessionFactory.create() → new KeycloakSession
    ↓
KeycloakSession.getProvider(X) → new Provider instance
    ↓
Provider работает в рамках запроса (KeycloakSession)
    ↓
KeycloakSession.close()
    ↓
Provider.close()
```

---

**`ComponentModel` (для многих SPI)**
- Конфигурация провайдера, сохранённая в БД (таблица `COMPONENT` и т.п.).
- Используется для многореализационных SPI (например, User Storage, Event Listener и т.п.).

---
**`Config.Scope`**
Config.Scope (для Quarkus) включает в себя:
- keycloak.conf
- переменные окружения (`KC_...`)
- аргументы командной строки
- живёт только на время `init()` у фабрики провайдера PhoneProvider

---


