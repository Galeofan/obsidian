---
tags:
  - ООП
---
**Интерфейс** — это абстрактный класс, в котором не реализован ни один метод. С помощью этих методов описывается некое поведение, которое должно быть реализовано в классах, применяющих этот интерфейс.

**Цель интерфейса** - абстрагировать интерфейс класса от его реализации.

В интерфейсе нельзя определять нестатические переменные, а методы, описывающие поведение классов-реализаций, должны быть пустыми (без реализации)

При определении методов в интерфейсе не требуется использовать модификаторы доступа, так как интерфейс создается с целью его реализации другими классами, поэтому эти методы по умолчанию имеют модификатор public, писать который в сигнатуре методов будет избыточно. То же самое касается и модификатора abstract. Все методы интерфейса неявно являются абстрактными (без реализации), что подразумевается самим понятием интерфейс (задает только поведение, но не реализацию), поэтому писать abstract в сигнатуру метода также будет избыточно.

Модификатор final неприменим в интерфейсах и их методах, так как в Java модификаторы abstract и final не могут быть объявлены в одной и той же сигнатуре.

#### Интерфейсы обладают особыми свойствами.

1. Не могут хранить состояния. Внутри интерфейса нельзя создать поля для сохранения в них данных (за исключением публичных статических финальных полей, которые просто являются константами, которые принадлежат всем классам которые реализуют этот интерфейс или наследуют класс, реализующий этот интерфейс).

2. Могут иметь множественное наследование. В java нет множественного наследования относительно классов. Зато в интерфейсах такая возможность есть.

3. Объявление методов без реализации. По сути это и есть контракт, как должен работать тот или иной объект, чтобы он мог использоваться в другой системе.
Например, USB вход. Универсальный интерфейс. С помощью него можно подключить любое устройство. Причем можно как читать данные, так и просто заряжать устройство. 

4. Реализация методов. По сути интерфейс - это тот же класс без состояния с возможностью множественного наследования.

Главное отличие полиморфизма через интерфейсы - это чистый код.

Один класс может реализовывать несколько интерфейсов. Если класс реализует несколько интерфейсов, он обязательно должен переопределять все абстрактные (без реализации) методы, которые описаны во всех этих интерфейсах.


Интерфейсы могут наследовать другие интерфейсы. В данном случае при реализации классом интерфейса-наследника, в этом классе должны быть переопределены методы обоих интерфейсов. Наследовать интерфейсы могут **только** другие интерфейсы, но не классы.


#### Отличия интерфейса и абстрактного класса
Абстрактный класс — это класс, у которого не реализован один и более методов. Он нужен для реализации семейства классов (отношение IS-A). Выглядит как заготовка под будущую реализацию. Также это средство для повторного использования кода.

Интерфейс — это абстрактный класс, в котором все методы не реализованы (помимо default, private, static), а также нет нестатических переменных. Интерфейс задает семантику класса. Вы всегда будете уверены, что класс, который реализует какой-либо интерфейс, реализует и все его методы, то есть поддерживает заданную семантику.

Любой интерфейс — это по существу абстрактный класс, но не наоборот. Несмотря на их схожесть, реального сходства между абстрактным классом и интерфейсом очень мало.

#### Поля
В интерфейсе могут быть объявлены поля, но на них накладываются некоторые ограничения. Эти поля должны быть проинициализированы сразу при объявлении, а также по умолчанию являются публичными (public), статическими (static) и неизменяемыми (final), то есть константами.
Пример:
```java
public interface Vehicle extends Fuel {
    int WHEELS = 4;
}
```
Это соответствует записи в обычном классе:
```java
public static final int WHEELS = 4;
```
Все переменные интерфейса неявно являются public static final (константами). Константы, как и абстрактные методы, наследуются производными интерфейсами от базовых.
#### Конструкторы
Интерфейс не может содержать конструкторов, так как интерфейс представляет собой абсолютную абстракцию, и вся реализация возложена на классы-реализации. Из-за отсутствия конструкторов создать экземпляр интерфейса невозможно.

#### Методы
Ранее интерфейсы могли содержать только абстрактные методы (без реализации). Начиная с Java 8, в интерфейсы можно включать методы с реализацией — статические (static) или дефолтные (default), а начиная с Java 9 — еще и приватные (private).

##### Статические методы
Статические методы принадлежат только интерфейсу, в котором объявлены, и не наследуются ни классами, реализующими интерфейс, ни интерфейсами-наследниками.
Статические методы можно использовать, когда необходимо сохранить какие-то данные на уровне интерфейса, которые могут быть использованы любым классом-реализацией при необходимости.

##### Дефолтные методы
Теперь рассмотрим дефолтные методы. Так же как и статические, они имеют реализацию, но при их объявлении используется ключевое слово default.
Главное отличие дефолтного метода в том, что он будет унаследован классом, который реализует данный интерфейс. При этом класс может как переопределить данный метод, так и воспользоваться реализацией по умолчанию.

##### Приватные методы
Последний тип методов, которые могут быть объявлены в интерфейсах — это приватные. Они обозначаются ключевым словом private. Приватные методы могут быть как статическими, так и нестатическими. Они используются в интерфейсах для того, чтобы вынести какую-то логику из публичных статических или дефолтных методов, либо для предотвращения дублирования кода. Приватные методы позволяют скрыть детали реализации, уменьшить пользовательский код и упростить его читаемость. Например, если один дефолтный метод должен возвращать среднее арифметическое элементов массива, а другой — удвоенную сумму элементов, мы можем вынести нахождение суммы элементов в отдельный приватный метод.
```java
package ru.job4j.polymorphism;

public interface FunctionOne {

    default double function(double x, double y) {
        return x * x - 2 * y + 30;
    }

    default void functionMessage() {
        System.out.println("Сообщение из FunctionOne");
    }

    default int getDoubleSum(int[] numbers) {
        return getSum(numbers) * 2;
    }

    default double getAverage(int[] numbers) {
        return getSum(numbers) * 1.0 / numbers.length;
    }

    private int getSum(int[] numbers) {
        int sum = 0;
        for (int number : numbers) {
            sum += number;
        }
        return sum;
    }
}
```

##### Вложенные / внутренние классы и интерфейсы
Интерфейсы могут содержать вложенные классы и интерфейсы, хотя такие конструкции используются редко. Внутренние классы и интерфейсы всегда являются public и static.
```java
public interface ExampleInterface {

    class ExampleClass {
        // код класса
    }

    interface InnerExampleInterface {
        // код интерфейса
    }

}
```
Также сам интерфейс может быть вложен в класс.
```java
public class ExampleClass {

    interface InnerExampleInterface {
        // код интерфейса
    }

}
```
Вложенные в класс интерфейсы предоставляют еще один уровень изоляции и организации кода. Такая схема чаще используется, когда нужно привязать интерфейс к классу, а не к пакету, либо этот интерфейс нужен только внутри этого класса для определенных целей.

##### Обобщенные типы

Обобщенные типы (generics) используются вместо указания конкретного типа, тем самым интерфейс может работать с разными типами данных, что позволяет избежать необходимости писать несколько одинаковых реализаций, отличающихся только типом данных. Обобщенные типы мы будем рассматривать на уровне Джуниор, поэтому сейчас просто достаточно запомнить,
что generics также можно использовать в интерфейсах.

В примере ниже T в угловых скобках (<T>) в сигнатуре интерфейса Parking означает, что вместо T может быть любой тип. Далее в классе-реализации CarParking мы реализуем интерфейс Parking с типом Car.

interface Parking<T> {
    void park(T car);
}

class CarParking implements Parking<Car> {
    public void park(Car car) { }
}
В другой реализации может быть объявлен другой тип, и это тоже будет работать.

##### Enum
Также в интерфейсе возможно объявить Enum (перечисление).

public interface Money {

    enum MoneyType {
        RUB, USD, EUR
    }

}