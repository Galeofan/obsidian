---
tags:
  - Collections
---
**Сортировка** - процесс упорядочивания данных.
Сортировка может быть двух видов: по возрастанию и по убыванию.

Для сортировки по возрастанию характерен порядок следования элементов от меньшего к большему. То есть каждый N элемент будет больше, чем N-1. Рассмотрим массив чисел: {5, 3, 1, 2}. После сортировки массив примет следующий вид: {1, 2, 3, 5}.

Для сортировки по убыванию характерен порядок, в котором элементы идут от большего к меньшему. То есть каждый N элемент будет меньше, чем N-1. Например: {5, 3, 1, 2}, после сортировки получим: {5, 3, 2, 1}.

Отсортировать можно не только числительные типы, но так же символьные типы. Все символы имеют порядковый номер в таблице ASCII.
Java автоматически может представить любой символ в таблице ASCII. Это свойство позволяет отсортировать любой массив с символами.
Например: {f, a, e, d} соответствуют кодам {102, 97, 101, 100}. После сортировки по возрастанию массив примет вид: {a, d, e, f}.

_Встроенная сортировка в Java_
В Java большинство коллекций поддерживает метод Collections.sort, который позволяет отсортировать коллекцию.
```java
package ru.job4j.collection;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ListSort {
    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(5, 3, 4, 1, 2);
        System.out.println(list);
        Collections.sort(list);
        System.out.println(list);
    }
}
```
1. Мы создали список из чисел и передали его в статический метод Collections.sort.
2. Java производит сортировку по возрастанию. Внутри метода sort осуществляется сортировка методом слияния.

Чтобы использовать алгоритм слияния, сортируемый тип данных должен поддерживать интерфейс java.util.Comparable. Все встроенные типы данных поддерживают этот интерфейс.

Интерфейс **Comparable** имеет всего один метод compareTo(T t). Этот метод возвращает меньше нуля, ноль, больше нуля.
Меньше нуля - если входящее значение больше, чем текущий объект.
Ноль - если значения равны.
Больше нуля - если текущее значение больше, чем входящее. Примечание. Текущее значение - это объект у которого вызван метод compareTo.

При сравнении строк каждая строка раскладывается на массив символов, которые в свою очередь преобразуются в массив чисел.
```java
String petr = "Petr";
String ivan = "Ivan";
int resultString = petr.compareTo(ivan);
System.out.println(resultString);
```
{P, e, t, r} -> {80, 101, 116, 114}
{I, v, a, n} -> {73, 118, 100, 110}
Дальше Java по очереди сравнивает каждую ячейку массива. Если вычисление дает результат 0, то вычисление повторяется для следующей пары, пока не дойдет до конца или пока результат не станет отличен от 0.
В этом примере, первое вычисление вернет число 7. Так как 80 - 73 = 7. То есть больше нуля. Это значит, что слово "Petr" больше, чем слово "Ivan".

_Сортировка по убыванию_
Через интерфейс java.util.Comparable мы можем задать только один порядок сортировки. Чтобы сделать другой порядок, в Java есть интерфейс, который не привязан к модели данных. Это интерфейс java.util.Comparator.

В нем есть метод int compare(T first, T second), который принимает сразу два параметра.

Для всех встроенных типов Integer, String и т.д. в Java есть готовые классы, реализующие этот интерфейс.

В классе java.util.Collections:
```java
public static <T> Comparator<T> reverseOrder() {
    return (Comparator<T>) ReverseComparator.REVERSE_ORDER;
}
```
Чтобы воспользоваться этим классом, в метод sort с коллекцией передается объект Comparator.
```java
List<Integer> list = Arrays.asList(5, 3, 4, 1, 2);
System.out.println(list);
Collections.sort(list, Collections.reverseOrder());
System.out.println(list);
```

 _Отличия  comparable от comparator_
 Comparable — это интерфейс, входящий в пакет java.lang
 Comparator — это интерфейс, входящий в пакет java.util

С помощью Comparable мы можем сортировать нашу коллекцию только на основе одного атрибута,
С помощью Comparator мы можем обеспечить собственную сортировку на основе нескольких атрибутов.

Comparable необходимо реализовать в классе, который требует сортировки
Comparator может быть реализован в другом классе или также может быть реализован с помощью лямбда-функции.

Если нам нужна сортировка по естественному упорядочению на основе одного атрибута, то следует отдать предпочтение Comparable, а если требуется несколько стратегий сравнения, вместо этого рекомендуется использовать интерфейс Comparator.

_Комбинированный компаратор_
В интерфейсе Comparator есть метод с реализацией по умолчанию - thenComparing. Этот метод принимает другой компаратор. Таким образом, можно соединить или скомбинировать любую сортировку.

```java
package ru.job4j.collection;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class JobSorter {
    public static void main(String[] args) {
        List<Job> jobs = Arrays.asList(
                new Job("Fix bug", 1),
                new Job("Fix bug", 4),
                new Job("Fix bug", 2),
                new Job("X task", 0)
        );
        Collections.sort(jobs, new JobDescByName().thenComparing(new JobDescByPriority()));
        System.out.println(jobs);
     }
}
```
Как работает комбинированный компаратор?
Если результат первого компаратора JobDescByName равен 0, то есть объекты равны, то проверка переходит ко второму компаратору JobDescByPriority.
Комбинировать компараторы можно до бесконечности.
Создадим компаратор, который сравнивает количество символов в имени.
